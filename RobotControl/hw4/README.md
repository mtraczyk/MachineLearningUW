---
title: Homework 4
---

# Updates:
 - added videos with example solutions
 - misleading mentions about the velocity sensor replaced with paragraphs about the accelerometer

# Submission format

**The submission deadline is Jan 30 (Tuesday), 8:00am 2024.**

You should submit via moodle. Submit only the two following files:
- `single_pid_task.py`
- `cascade_pid_task.py`
- `pid.py`

General notes:
- if you submit any other files you will get **-1 point penalty**!
- if you submit files with changed simulation conditions (see details below), you will get **-1 point penalty**

# Goals:

- implement a PID controller in MuJoCo to control altitude of a flying drone
- implement a cascade PID control to get a more robust behaviour of the drone

# Requirements

MuJoCo 3.0 or later

# Description

## Overview

The homework is based on the problem discussed in the first and the last video of [this](https://youtube.com/playlist?list=PLn8PRpmsu08pQBgjxYFXSsODEF3Jqmm-y&si=LTdF48nP-bvG1kfO) playlist, namely: flying a drone at a given altitude.
Your goal is to implement PID control which the drone will use to hover at a specified height.
There are two tasks:

1. In the first task you should directly control the thrust of the propellers based on the measurements of the altitude using single PID controller.
In this task we make a (rather arificial) assumption that you have access to measurements of the current altitude at very high frequency.
2. In the second task we make the problem more real and hence have to create more robust control.
Namely:
    - we introduce gusts of wind which change randomly and can disturb the drone
    - the altitude sensor's frequency is significantly decreased
    - we have access to a sensor measuring acceleration which operates at a very high frequency

## Assets

### Skydio X2

In this homework we use a simplified robot description (MJCF) of the [Skydio X2](https://www.skydio.com/skydio-x2) drone developed by [Skydio](https://www.skydio.com/).
The model and necessary assets were downloaded from [mujoco_menagerie](https://github.com/google-deepmind/mujoco_menagerie).
You can find many interesting models in this repository.
It is developped by google-deepmind.

![Image description](x2.png){: width="400" }

### Drone Simulator

Except the assets from Skydio, you are given a `drone_simulator.py` script.
You should not edit this script as it will not be a part of your submission.

Inside the script you can find the definiton of a `DroneSimulator` class.
It contains attributes and methods to run a simulated flight of a drone.
It is easier to have a general class for the simulation, because the conditions in the first and second task are different and this way we can easily change them with class attributes.

In each task the specific instances and calls to run a simulation will already be prepared for you.
To complete the tasks you have to know three things about the class:

1. how parameters given to the specific instance determine the conditions
2. how we model the wind gusts
3. how to get the sensor parameters and readings from the instance.

#### Drone Simulator instance

Assuming that a `DroneSimulation` was instantiated in the following way:

```python
drone_simulator = DroneSimulator(
        model, data, viewer, desired_altitude = desired_altitude,
        altitude_sensor_freq = 0.01, wind_change_prob = 0.1, rendering_freq = 1
        )
```

we can easily deduce the conditions of the simulation. Namely:

- `model`, `data` and `viewer` parameters are simply objects created with `mujoco` package which build a model and allow us to view the simulation
- `altitude_sensor_freq` determines how often we get sensor readings during the simulation.
A frequency of 0.01 means that we receive readings every hundredth step.
We will discuss it more in the second task description.
- `wind_change_prob` is a value between `0` and `1` and determines the probability that the wind will change in the next simulation step.

#### Modelling the wind gusts

It is probably important to mention how we model the wind gusts.
Here is a brief summary:
- We are interested only in the motion in the vertical direction, so we assume that there are no wind gusts in the horizontal direction.
- The real wind gusts apply a force on a drone.
The easiest way to apply a force on a drone in the Skydio model is by setting thrust on the propellers.
Hence we model the wind by adding random value between `-1` and `1` on each of the four propellers
- We assume that the force applied on the drone between the wind changes is constant.
To be more specific, the `wind_change_prob` attribute of `DroneSimulation` determines how likely the wind will change in the next simulation step.
If the wind is to be changed, a random value between -1 and 1 is drawn.
This value is added to the thrust generated by the propellers **in each subsequent simulation step**.
This process continues until another random wind change is generated and a new wind strength is chosen.

All of this happens in the following lines inside `drone_simulator.py`:

```python
def sim_step(self, thrust, steps=1, view=True):
    if np.random.uniform() < self.wind_change_prob:
        self.wind_strength = np.random.uniform(-1, 1)
    self.data.actuator("thrust1").ctrl = thrust + self.wind_strength
    self.data.actuator("thrust2").ctrl = thrust + self.wind_strength
    self.data.actuator("thrust3").ctrl = thrust + self.wind_strength
    self.data.actuator("thrust4").ctrl = thrust + self.wind_strength
```


#### Sensors

Assuming that an instance of the `DroneSimulation` class was stored in a `drone_simulator` variable, you can get the altitude sensor readings with `drone_simulator.measured_altitudes`.
The readings are stored as a list with two values:

- the most recent reading
- the previous reading

If you need a time period between two consequtive sensor readings you can call `drone_simulator.altitude_sensor_period`.

Acceleration sensor is implemented as a part of a Skydio model.
We will discuss how to use it during the second task.

#### Summary

This is all you should need to implement the control for the drone.
If you want to understand the `DroneSimulation` class better, you are always encouraged to go through the class definition.

## Task 1 - Single PID Controller

The drone flies because of the thrust generated at the propellers.
In the first task you will directly control the thrust based on the altitude measurements, i.e. we will use a single PID controller.

You have two goals:

- complete the implementation of a class `PID` for a general PID controller - this is delegated to the `pid.py` script
- find appropriate gains and use a `PID` instance to control the altitude of the drone - this happens in the `single_pid_task.py` script.

Note that in this task we assume:

- the sensor measuring altitude operates at a very high frequency, i.e. in each simulation step we have access to the most recent altitude
- there is no wind

Start by running the `single_pid_task.py` script and making sure that everything works.
The drone should stay on the ground, because there is no thrust generated by the propellers.

Now proceed to the `pid.py` and complete the implementation of the `PID` class.
You will use instances of this class to create PID controllers in your solutions for both the first and the second task.

With the `PID` class implemented move to the `single_pid_script.py`.
An instance of the `PID` class is prepared for you:

```python
pid_altitude = PID(
    gain_prop = 0, gain_int = 0, gain_der = 0,
    sensor_period = drone_simulator.altitude_sensor_period
    )
```

If you have properly implemented the `PID` class, you should be able to find appropriate gains to lift off the drone and fly it to the desired altitude.
Make sure that you submit a script with only the values of the gains changed.

We expect your solution to have at least as good performance as in the below video with an example solution:

<video width="512" height="208" controls>
  <source src="single-pid-example-solution.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

## Task 2 - Cascade PID Controller

In the second task we will make the conditions more real by:
- lowering the frequency at which we get altitude measurements
- introducing wind gusts
- using a second sensor which measures the current acceleration of the drone and operates at a high frequency

You can see the first two aspects if you inspect the instance of the `DroneSimulation` class inside the `cascade_pid_task.py` script:

```python
drone_simulator = DroneSimulator(
    model, data, viewer, desired_altitude = desired_altitude,
    altitude_sensor_freq = 0.01, wind_change_prob = 0.1, rendering_freq = 1
    )
```

As you can see:
- `altitude_sensor_freq = 0.01` so we get a new information about the altitude every 100th simulation step
- `wind_change_prob = 0.1` so in each iteration there is 10% chance that the wind will change.
Hence on average the wind changes every 10th iteration.

You can attempt to utilize the PID control you have developed in the first task in this scenario.
It is extremely probable that your implementation will malfunction severely.
It is essential to note that even if you eliminate the random wind gusts (i.e., set `wind_change_prob = 0`), your implementation from the initial task will probably still falter.
The most significant distinction is therefore the change in the sensor's frequency.

Luckily, if you inspect the Skydio model, there are a few sensors attached to the drone:

```xml
<sensor>
    <gyro name="body_gyro" site="imu"/>
    <accelerometer name="body_linacc" site="imu"/>
    <framequat name="body_quat" objtype="site" objname="imu"/>
</sensor>
```

We are interested in the accelerometer, which tells us the current acceleration of the drone.
This sensor provides new readings at each simulation step.
You can get its readings with `data.sensor("body_linacc").data`.
The result is a list with the current acceleration of the drone in the x, y and z directions.
Since we are interested only in the movement in the z direction we should call `data.sensor("body_linacc").data[2]`.

Why is this setup less artificial?
There are different measurements we can measure from a perspective of a system.
Some have to be measured relatively to other things (like the position) and some can be measured locally (like the acceleration with an accelerometer).
Obviously the local measurements can be often measured at a much higher frequency than the relative ones.
There might be various reasons for that.
For example becuase of the time required to complete the operation or the need to average consequtive the measurements to get rid of the noise.
Actually, on a high level exactly the same setup as we discuss here is used by your phone to determine your localisation when you go for a walk or a run.
The information from a GPS  - gathered at a low frequency - is combined with data from an accelerometer - collected at a high frequency - to iteratively update your position.

Coming back to the task. Your goal is to:

1. Create two instances of a `PID` class:
    - inner loop PID controller which controls thrust based on the acceleration
    - outer loop PID controller which controls acceleration based on the altitude
2. Use the PID controllers in cascade design to place the drone at the desired altitude.

You should instantiate the PID controllers here:

```python
# TODO: Create necessary PID controllers using PID class
    ...
```

and use them in the cascade design here:

```python
# Increase the number of iterations for a longer simulation
    for i in range(4000):
        # TODO: Use the PID controllers in a cascade designe to control the drone
        ...
        drone_simulator.sim_step(0)
```

This time you have to organize the readings from the acceleration sensor and determine it's frequency / period between readings on your own.
Remember that when dealing with the acceleration you have to take into account the gravitational acceleration.
For example, for a drone standing on the ground the acceleration is approximately `9.8`, not `0`!

Another thing to keep in mind is that we do not require you to use full PID controllers at any level.
If you find a good solution with some gains equal to zero it's fine.
In other words, it's perfectly acceptable to use, for example, a PI (`gain_der=0`) outer loop controller with a PD (`gain_int=0`) inner loop controller.
Just design a system which works efficiently.

Finally, note that since the conditions in this task are more difficult, we have increased the number of simulation steps (from `2000` to `4000`) to give the drone more time to stabilize.
You can change the simulation time or wind conditions when working on the problem.
Just remember that at the end your solution should work in exactly the conditions specified in the task.
So make sure to test and submit your solution with all of the parameters unchanged.

We expect your solution to have at least as good performance as in the below video with an example solution:

<video width="512" height="208" controls>
  <source src="cascade-pid-example-solution.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

# References and Licenses

The [Skydio X2](https://www.skydio.com/skydio-x2) model is released under an [Apache-2.0 License](LICENSE). No changes were made to the original model.
